## JAVA基础

### 1、JVM内存分配原理，垃圾回收原理

```
jvm内存模型：Java代码是运行在Java虚拟机之上的. 由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成. 故Java内存模型. 也就是指Java虚拟机的运行时内存模型。

运行时内存模型. 分为线程私有和共享数据区两大类. 其中线程私有的数据区包含程序计数器、虚拟机栈、本地方法栈. 所有线程共享的数据区包含Java堆、方法区. 在方法区内有一个常量池。

堆:Java中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。在 Java 中，堆被划分成两个不同的区域：新生代(Young)、老年代 (Old)。新生代 (Young)又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

虚拟机栈:方法执行的内存区.每个方法执行时会在虚拟机栈中创建栈帧，存储的都是局部变量 (方法中定义的变量.方法上的参数. 语句中的变量);只要数据运算完成所在的区域结束. 该数据就会被释放。特点是先进后出。

本地方法栈:虚拟机的Native方法执行的内存区；用于执行本地方法。C语言. C++方法就是本地方法。

方法区:存放类信息、常量、静态变量、编译器编译后的代码等数据；常量池：存放编译器生成的各种字面量和符号引用. 是方法区的一部分。

程序计数器:记录正在执行的虚拟机字节码地址,用于控制程序执行代码的顺序
```

```
分代是垃圾回收机制的策略，具体细分为新生代和老年代
新生代用于存放新生的对象，一般占据堆的1/3空间，由于频繁创建对象，所以
包括Eden区，From Survivor区和To Survivor区

常用GC算法
1.Mark-Sweep（标记-清除）算法 标记需要回收的对象，然后清除，会造成许多内存碎片。
2.Copying（复制）算法 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。
3.Mark-Compact（标记-整理）算法（压缩法） 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。
4.Generational Collection（分代收集）算法 分为年轻代和老年代，年轻代时比较活跃的对象，使用复制算法做垃圾回收。老年代每次回收只回收少量对象，使用标记整理法。

典型垃圾回收器
1.CMS，
	以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是 Mark-Sweep 算法。
	场景：如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的 CPU 资源也比较丰富，就适合适用 CMS 收集器。
	缺点：
	- 并发标记时和应用程序同时进行，占用一部分线程，所以吞吐量有所下降。
	- 并发清除时和应用程序同时进行，这段时间产生的垃圾就要等下一次 GC 再清除。
	- 采用的标记清除算法，产生内存碎片，如果要新建大对象，会提前触发 Full GC 。
2.G1，
	是一款面向服务端应用的收集器，它能充分利用多 CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型，即可以设置 STW 的时间。
	特点：
	- 并发与并行 充分利用多核 CPU ，使用多核来缩短 STW 时间，部分需要停顿应用线程的操作，仍然可以通过并发保证应用程序的执行。
	- 分代回收 新生代，幸存带，老年代
	- 空间整合 总体看是采用标记整理算法回收，每个 Region 大小相等，通过复制来回收。
	- 可预测的停顿时间 使用 -XX:MaxGCPauseMillis=200 设置最长目标暂停值。
```

### 2、ConcurrentHashMap 和 hashMap,hashTable底层结构的区别

```
Hashtable的大部分方法做了同步，HashMap没有，因此，HashMap不是线程安全的。
Hashtable不允许key或者value使用null值，而HashMap可以。
在内部算法上，它们对key的hash算法和hash值到内存索引的映射算法不同。
HashTable线程安全则是依靠方法简单粗暴的sychronized修饰，HashMap则没有相关的线程安全问题考虑。。
在ConcurrentHashMap中，引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。
通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍。
```

### 3、多线程创建的几种方式，现场池的原理和你常使用的线程池的类

```
1.继承Thread类,重写run方法
2.实现Runnable接口,重写run方法
3.实现Callable接口,重写call方法,跟Runnable相比有返回值,用future获取
4.线程池获取线程
```

```
线程池的原理: 
其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。

线程池主要参数
corePoolSize: 规定线程池有几个线程(worker)在运行。
maximumPoolSize: 当workQueue满了,不能添加任务的时候，这个参数才会生效。规定线程池最多只能有多少个线程(worker)在执行。
keepAliveTime: 超出corePoolSize大小的那些线程的生存时间,这些线程如果长时间没有执行任务并且超过了keepAliveTime设定的时间，就会消亡。
unit: 生存时间对于的单位
workQueue: 存放任务的队列
threadFactory: 创建线程的工厂
handler: 当workQueue已经满了，并且线程池线程数已经达到maximumPoolSize，将执行拒绝策略

4种线程池
Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。
ExecutorService xxxPool=Executors.newXXXPool();
xxxPool.execute(new Runnable(){...});

1.newCachedThreadPool 
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪

2.newFixedThreadPool
创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。
FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

3.newSingleThreadExecutor
创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。

4.newScheduleThreadPool
创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。
```

### 4、synchronized、volatile 这两个关键字的作用和区别

```
synochronized关键字可以解决线程安全问题,提供了互斥性，可见性以及原子性。
他可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。

volatile关键字可以在多线程的环境下保证变量的可见性,在变量修改后会立即同步到主内存中,每次用这个变量前都会从主存刷新，初此之外它还能防止指令重排。

区别
1.修饰对象不同，volatile用于修饰变量，synchronized用与对语句和方法加锁；
2.各自作用不同，volatile保证数据的可见性和有序性，但它并不能保证数据的原子性，synchronized可以保证原子性；
3.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；
```

### 5、Spring AOP底层实现的原理，动态代理

```
AOP就是要对目标进行代理对象的创建，底层是基于动态代理的，基于两种动态代理机制：JDK动态代理和CGLIB动态代理。
如果目标对象实现了接口，默认采用jdk的动态代理，也可以强制转为CGLib实现AOP，如果没有实现接口，采用CGlib动态代理

1.JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象
2.CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以再运行期动态生成新的 class。
和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。
```

### 6、设计模式，重点问下动态代理模式，职责链模式

```
23个设计模式
创建型模式
1.单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2.工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
3.抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

结构型模式
4.代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性，起到了保护了目标对象的作用，同时也在一定程度上面减少了系统的耦合度。
5.适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

行为型模式
6.职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合
7.状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
8.观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
```

### 7、Spring IOC类加载的顺序

```
1.读取Bean的配置信息（xml中的<bean>，java类中有@Configuration，通过注解@Autowrite）
2.将读取到的Bean的配置信息放入Spring配置的容器中的Bean定义的注册表，通过注册表将Bean实例化到Bean的实现类中，形成依赖注入
3.再将Bean实例放入Spring容器中的Bean的缓存池
4.如果需要，就从SpringIOC中的缓存池中取出
```

### 8、Spring中BeanFactory和ApplicationContext的区别，bean是否是线程安全的 哪种是延迟加载

```
BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext是它的子接口

ApplicationContext: (更多采用此接口)
	单例对象使用(线程安全)
	它在构建核心容器时,创建对象采取的策略是采用**立即加载**的方式;也就是说,只要一读取完配置文件马上就创建配置文件中的配置对象
BeanFactory:     
	多例对象使用(线程不安全)
	它在构建核心容器时,创建对象采取的策略是采用**延迟加载**的方式;也就是说,什么时候根据id获取对象,什么时候才真正的创建对象
```

### 9、Java实现访问公网返回json文件

```java
public static String loadJson (String url) { 
    StringBuilder json = new StringBuilder(); 
    try { 
      URL urlObject = new URL(url); 
      URLConnection uc = urlObject.openConnection(); 
      BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream(),"UTF-8")); 
      String inputLine = null; 
      while ( (inputLine = in.readLine()) != null) { 
        json.append(inputLine); 
      } 
      in.close(); 
    } catch (MalformedURLException e) { 
      e.printStackTrace(); 
    } catch (IOException e) { 
      e.printStackTrace(); 
    } 
    return json.toString(); 
}
```

## 微服务/分布式框架

### 1、http 协议和 RPC 协议的区别

```
1.RPC是传输层协议(4层).而HTTP协议是应用层协议(7层).
2.RPC协议可以直接调用中立接口,HTTP协议不可以.
3.RPC通信协议是长链接,HTTP协议一般采用短连接需要3次握手(可以配置长链接添加请求头Keep-Alive: timeout=20).
(长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。)
4.RPC协议传递数据是加密压缩传输.HTTP协议需要传递大量的请求头信息.
5.RPC协议一般都有注册中心.有丰富的监控机制.
```

### 2、http 协议 方法 POST,GET,PUT DELETE 4中方法的区别

```
1、GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。

2、与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。

3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。

4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。

就像前面所讲的一样，既然PUT和POST操作都是向服务器端发送数据的，那么两者有什么区别呢。。。POST主要作用在一个集合资源之上的（url），而PUT主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。

综上所述，我们可理解为以下：

1、POST /url 创建
2、DELETE /url/xxx 删除 
3、PUT /url/xxx 更新
4、GET /url/xxx 查看
```

### 3、讲下使用的微服务框架是什么（spring-cloud 或者 dubbo），讲下微服务框架常见的组件和作用

```
spring cloud
注册中心(eureka) - 服务发现和调度组件
服务调度组件(ribbon) - 负载均衡器(默认轮询)
声明式RESTFUL客户端(feign) - 一个声明性的web服务客户端,它使编写web服务客户机变得更容易，Feign采用的是接口加注释并且整合了ribbon
熔断器(hystrix) - 集群中某个节点出现异常,触发熔断,保护后端服务,防止服务雪崩，降级处理 (返回一个空/自定义数据)
服务网关(zuul) - 根据请求的特征将请求分发到相应的服务中。
配置中心(config) - 解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。
数据监控(acutor) - 实时监控，会实时,累加地记录所有关于HystrixCommand的执行信息, 包括每秒执行多少请求,多少成功,多少失败
```

### 4、分布式锁和分布式事务如何处理

```
分布式锁的几种方案
1.基于数据库做分布式锁 锁对象是数据库中的行记录，插入成功，获取锁，删除行释放锁
	创建一张锁表，因为数据库对所有进程可见，所有进程都可以操作该表改变锁的状态。
当我们锁住某个方法或资源时，我们在表中增加一条记录，释放锁的时候，删除该记录。其他进程看到锁表这行记录为空，就说明没有进程在执行方法，反之则有线程在执行方法。
	具体操作：
		在数据库中创建一张表，方法名为索引，线程想要执行该方法时，就使用方法名向表中插入数据。成功插入则获取锁，执行完后删除行释放锁。
	问题：
		1.这张表强依赖于数据库的可用性，数据库是一个单点，一旦挂掉，就没有锁了。线程无法判断该方法是否有别的线程在执行
		解决：搞两个数据库，数据之前双向同步，一旦挂掉切换到备份。
		2.这把锁没有失效时间，一旦删除行失败，其他线程就没办法获得锁
		解决：做个定时任务，每个一段时间把数据库中的超时数据清理一遍。
		3.这把锁是非阻塞的，因为一旦插入失败，直接报错。没有获得锁的线程不会进入排队队列，想要再次获得锁，再次触发获得锁操作。理想：获得锁失败阻塞，等待被唤醒，现在获得锁失败，再次触发获得锁操作。（？）
		解决：while循环直到insert成功。
		4.非重入：同一个线程在没有释放锁之前无法再次获得锁
		解决：在数据库表中加个字段，记录线程信息及其机器信息。下次再次获取锁的时候，查询数据库，如果信息匹配，则直接获取锁。
	优点：借助数据库，方案简单
	缺点：实现过程中遇到各种问题，为解决这些问题，实现方式会越来越复杂。依赖数据库需要开销，数据库优化有可能造成表锁。
	
2.基于Redis实现分布式锁 锁对象是缓存中存储的key-value元素，set成功获取锁(失效时间)，del或到了过期时间释放锁
	Redis2.6.12版本之前，使用setnx命令设置key-value,使用expire命令设置key的过期时间，获取分布式锁，使用del删除分布式锁：
	问题：
		设置key-value后，还没来得及设置过期时间，线程就挂掉了，那么这个key-value一直在缓存中，别的线程无法获取锁。
		解决：
			将两个操作合成一个原子操作。(SET(keyName, lockvalue, ‘NX’, ‘EX’, expireSecond))
			set成功获取锁，否则失败。设置value要有唯一性，来确保不会被误删，value=系统时间戳+UUID
			客户端通过del释放锁或者锁到了失效时间，自动释放。
			只有当key的value和传入的value相同时，才会被删除。

	优点：高性能，借助redis方便。
	缺点：失效时间不好确定，设置少了，提前失效，还是会产生并发问题，设置长了，会让其他线程白白等待。

3.基于Zookeeper实现分布式锁，Zookper是一个为分布式应用提供一致性服务的开源组件。内部是一个分层文件系统目录树结构，每个目录下只能有唯一个文件名。
	临时节点：由客户端创建，客户端与ZK连接断开，临时节点被删除，可以防止创建了锁但突然故障造成锁没有被删除导致其他线程无法获得锁而造成的死锁。
	基于Zookeeper实现分布式步骤：
		1.创建一个目录mylock
		2.线程A想要获取锁就在mylock目录下创建临时顺序节点；
		3.创建完毕后，获取mylock目录下的所有子节点，看自己是不是最小的那个，是则获取锁。不是则监视比自己小的那个最大节点，进入等待，直到监听的节点状态变更时，再获取子节点，判断是否获取锁。
		4.释放锁就直接删除自己创建的那个子节点。
	优点：高可用，可重入，阻塞锁特性，可以解决失效死锁问题。

	解决锁无法释放的问题：客户端为获取锁在ZK中创建的是临时节点，一旦客户端获取锁之后突然挂掉(和ZK的session连接断开)，那么临时节点就会自动删除。其他客户端可以再次获得。
	
	阻塞锁特性：别的线程因为自己是最小的节点获取到锁了，那么其他线程创建的不是最小节点，会阻塞，此时他会在比他小的节点中绑定一个监听器，一旦比他小的节点释放锁了，这个监听到了，就会再次判断自己是不是最小的节点来获取锁。
	可重入：客户端在创建节点的时候，把当前客户端的主机信息和线程信息写到节点中，下次想要获取锁的时候，就判断最小的节点中的数据对比一下就好了，如果一样直接获取锁，不一样则在创建一个新的临时顺序节点参与排序。
	单点问题：ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务了。
	用分布式锁来防止库存超卖。
```

```
事务ACID底层实现，锁加日志
	A：undo log
	C：锁
	I：写(锁),读(MVCC-多版本控制协议，读不加锁)
	D：redo log
	
分布式事务 
	分布式事务目的是保证分库数据一致性
	
	CAP理论
		Consistency：一致性，分布式环境下多个节点的数据是否强一致
		Avalability: 可用性, 分布式服务能一直保证可用状态，在有限时间内返回结果。
		Partition Tolerance：分区容忍性，对网络分区的容忍性，分布式是不可或缺的。
	CAP原则:这三个要素最多只能同时实现两点，不可能三者兼顾
	举例：Cassandra、Dynamo 等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。

	BASE理论：可以放弃系统在每个时刻的强一致性来换取系统的可扩展性。
	核心思想：
		基本可用(BasicallyAvailable): 指分布式系统在出现故障时，允许部分损失的可用性来保证核心可用。
		软状态(Soft State)：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。
		最终一致性(Eventual Consistency)：指分布式系统中的所有副本数据经过一段时间后，最终能够达到一致的状态。
		
	一个事务中的模块在不同的系统中，要保证这些处在同一个事务中的模块要么全部执行，要么全都不执行。由于模块分布在不同系统中，要想这些系统直到对方是否执行成功，就使用MQ消息队列作为中间商，告诉另一个系统对方系统是否执行成功。如：A系统执行成功，发送确认消息成功到MQ，B收到确定消息，会不断重试保证自己一定执行成功，如果不成功，则人工回滚或人工干完B的操作。A系统执行不成功，MQ是不会发送消息给B系统的。
	
	数据一致性模型可分为3类：
		1.强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。
		2.弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承认诺具体多久之后可以读到。
		3.最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺若立即返回最新写入的值，但是保证最终会返回上一次更新操作的值。
		
	分布式事务解决方案
		1.2PC方案(XA两阶段提交方案)——强一致性 （可扩展性很差，效率很低，绝不适合高并发场景）
			两阶段提交，有一个事务管理器的概念，负责协调多个数据库(资源管理器)的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都恢回复OK，那就正式提交事务，在各个数据库上执行操作；如果其中任何一个数据库回答不OK，那么就回滚事务。
			问题
				1. 单点故障: 协调者出错,导致事务会失败
  					 解决方案: 搭建集群(阿里Seata 注解@GlobalTransactional)
				2. 阻塞资源: 占用数据库连接,性能低(3pc方案可以解决该问题，can/pre/do commit)
				3. 数据不一致: 二阶段出错,数据不一致(概率极低,鸵鸟算法)
		2.eBay事件队列解决方案(本地消息表)——最终一致性
			它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。
			描述的场景为，有用户表user 和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。
			这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。
		3.TCC(Try-Confirm_cancel) 补偿式最终一致性 （几乎很少人使用）
			Try：先把两个银行账户中的资金给它冻结住就不让操作了；
			Confirm：执行实际的转账操作，A 银行账户的资金扣减，B 银行账户的资金增加；
			Cancel：任何一个服务的业务方法执行出错，回滚。
		几乎很少人使用，事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。
		跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚。
		4.缓存数据最终一致性（可靠消息最终一致性方案）
			A系统处理处理事务之前，发送一个prepared消息到MQ，如果这个prepared消息发送失败，直接取消事务操作。如果消息发送成功，A再执行事务，执行事务失败，告诉MQ回滚消息，如果成功告诉MQ确认消息。A发送确认消息如果失败了呢，消息停留在prepared状态？MQ会自动轮询所有prepared消息，回调系统A的接口，这个消息是不是本地事务处理失败了，所以没发送确定消息，是继续重试还是回滚。这就避免了本地事务成功了，而没发送确认消息。
			如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
			这个方案里，要是系统 B 的事务失败了咋办？重试咯，MQ自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。
			适用场景： 这个方案的使用还是比较广，目前国内互联网公司大都是基于这种思路玩儿的。
		5.最大努力通知方案 （一般用在不太重要的业务操作中）
			1.系统 A 本地事务执行完之后，发送个消息到 MQ。
			2.这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ，然后写入数据库中记录下来，或者是放入个内存队列。
			3.接着调用系统 B 的接口。假如系统 B 执行成功就万事 ok 了，但是如果系统 B 执行失败了呢？ 那么此时最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。
```

### 5、Redis 是否可以持久化，Redis 集群扩容怎么做

```
Redis可以持久化，有三种个持久化机制RDB，AOF和混合持久化
Redis默认持久化是RDB，以数据快照(二进制)形式保存，不能实时写入，恢复速度快
AOF以独立日志(文本)形式保存，支持实时写入
```

```
1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。

2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。

3.redis cluster3.0自带的集群，特点在于Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。
```

### 6、消息队列常用的是那些（MQ）,消息补偿的机制是怎么做的

```
Kafka
优点： 吞吐量非常大，性能非常好，集群高可用。
缺点：会丢数据，功能比较单一。
使用场景：日志分析、大数据采集
RabbitMQ
优点： 消息可靠性高，功能全面。
缺点：吞吐量比较低，消息积累会严重影响性能。erlang语言不好定制。
使用场景：小规模场景。
RocketMQ
优点：高吞吐、高性能、高可用，功能非常全面。
缺点：开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支
持java。
使用场景：几乎是全场景。
ActiveMQ
优点：老牌的消息队列，使用Java语言编写。对JMS支持最好，采用多线程并发，资源消耗比较大。如果语言是Java，可以重点考虑。
缺点：由于历史悠久，历史包袱较多，版本更新很缓慢。集群模式需要依赖Zookeeper实现。最新架构的产品被命名为Apollo，号称下一代ActiveMQ，目前案例较少。

mq数据丢失问题
1.消息提供者丢失，使用confirm机制，每次发消息都会有个消息id，发送给mq，mq收到了就回应ack就是ok给提供者，否则就调用回调接口并再次发送。
2.mq数据丢失，开启持久化操作，queue不会丢失，参数设置两个持久化，只要持久化成功，就算宕机消息都不会丢失。当然如果持久化之前宕机，消息还是会丢失，但是发生概率很小。这时候可以使用前面的confirm机制处理，当mq接收到消息并持久化成功后再发送ack给消息提供者。这样就算持久化没成功就宕机，提供者还是会再次发送消息。
3.消息消费者丢失，使用ack机制，mq发送消息给消费者，消费者执行完成后返回ack给mq，mq再删除该消息。如果消费者没处理完就出问题宕机，mq可以发送给其他消费者处理直到拿到ack。
```

## 数据库

### 1、mysql 查询去重如何做

```
Distinct/group by(效率较高)
```

### 2、mysql select * from table for update 是什么意思（行锁）

```
where指定主键/索引查到了	   行锁(悲观锁)
没有指定主键/索引		 	表锁
指定主键/索引查不到 		   无锁
```

### 3、mysql union 和 union all 这两个关键字的区别是什么

```
UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。
1、对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。
2、对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。
3、从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。
```

### 4、SQL优化的一般步骤是什么，怎么看执行计划（explain关键字），如何理解其中各个字段的含义。

```
通过 show status 命令了解各种sql的执行频率
定位执行效率较低的sql语句
通过explain分析低效sql的执行计划
通过 show profile 分析sql
通过trace分析 优化器 如何选择执行计划
确定问题并采取相应的优化措施

字段
1.id 列中的数据为一组数字，表示执行select语句顺序,值相同,执行顺序由上至下,值越大优先级越高.
2.select_type 查询类型,主要用于区分普通查询,联合查询,子查询等复杂查询
	Simple
	Primary
	Subquery
	Derived
	Union
	Union Result
	Dependent Subquery
	Dependent union
	
3.table 输出数据行所在的表名称
4.type 访问类型,sql查询优化中一个很重要的指标，结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

5.possible_keys 指出mysql能使用哪些索引来优化查询
6.key 实际使用的索引，如果为NULL，则没有使用索引
7.key_len 表示索引字段的最大的可能长度
8.rel 表示那些列或常量被用于查找索引列上的值
9.rows 表示msql通过索引的统计信息，估算的所需读取的行数
10.Extra
	Distinct 优化distinct操作，在找到第一匹配的元祖后即停止找同样的动作
	Not exists 使用 not exists 来优化查询
	Using filesort 使用额外操作进行排序，通常会出现在order by 或 group by 查询
	Using index 使用了覆盖索引进行查询
	Using temporary mysql需要使用临时表来处理查询，常见于排序，子查询，和分组查询
	Using where 需要在mysql服务器层使用 where条件来过滤数据
	slect tables /optimized away 直接通过索引来获得数据，不用访问表
```

### 5、MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。

```
索引原理
	Mysql 实际使用的 B+Tree 作为索引的数据结构
	只在叶子节点带有指向记录的指针（可以增加树的度）
	叶子节点数据 key 从左到右是递增的并且通过指针相连（实现范围查询）


索引有
	普通类型（CREATE INDEX)
	唯一索引，索引列的值必须唯一（CREATE UNIQUE INDEX)
	多列索引
	主键索引（PRIMARY KEY），一个表只能有一个
	全文索引（FULLTEXT INDEX），InnoDB 不支持
	
创建合理的索引
	经常用作查询条件的字段
	经常用作表连接的字段
	经常出现在 order by，group by 之后的字段
	
索引优化
	非空字段 NOT NULL，Mysql 很难对空值作查询优化
	区分度高，离散度大，作为索引的字段值尽量不要有大量相同值
    索引的长度不要太长（比较耗费时间）
    
防止索引失效
1.避免使用like以%开头
2.or语句前后没有同时使用索引
3.使用组合索引时要注意顺序比如组合索引设置(abc),只要使用a,ab,abc时索引才会生效
4.数据类型出现隐式转化(如varchar不加单引号可能会自动转换成int,索引失效,产生全表扫描)
5.索引列上使用IS NULL或IS NOT NULL操作,主要索引会失效(例如where id is null)
6.in/not in
7.!=/<>
    
创建外键
alter table 表名 add constraint 外键约束名 foreign key(你的外键字段名) REFERENCES 外表表名(对应的表的主键字段名)

创建索引
CREATE INDEX index_name ON table_name (column_list)
```

### 6.mysql事务注意事项

```
mysql默认自动提交事务，可以使用set autocommit=0关闭自动提交事务

在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter/table)、lock tables语句等等。

不过，常用的select、insert、update和delete命令，都不会强制提交事务。
```

## 其他

### 1.Map有哪些线程安全的和线程不安全的?

```
安全：HashTable,CorrentHashMap
不安全：HashMap，TreeMap，LinkedHashMap
```

### 2.concurrentHashMap1.7和1.8做了哪些优化?

```
- 线程安全的HashMap
- 1.7采用分段锁的形式的加锁(ReentrantLock+Segment+HashEntry)
- 1.8使用Synchronized和CAS实现同步(数据结构-> HashEntry+红黑树),若数组的Node为空,则通过CAS的方式设置值,不为空则加在链表的第一个节点; 获取第一个元素释放为空使用Unsafe类提供的getObjectVolatile保证可见性.
- 对于读操作,数组由volatile修饰,同时数组的元素为Node,Node的K使用final修饰V使用volatile修饰,下一节点也用volatile修饰,保证多线程的可见性.

ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表
```

### 3.Map的key存的是自定义对象,需要注意那些点?

```
重写HashCode和equals方法
```

### 4.说一说自己了解的锁,随便说?

```
Jvm提供的synchronized
JDK提供的各种锁如ReentrantLock

synchronized
- 在JDK1.5中,synchronized性能是低效的, 因为这是个重量级的操作,它对性能最大的影响是阻塞式的实现,挂起线程和恢复线程的操作都需要转入内核态中完成,这些操作给系统的并发性带来了很大的压力,相比之下使用Java提供的Lock对象,性能更高一些;
- JDK1.6对synchronized进行了优化,有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。因此。提倡优先考虑使用synchronized来进行同步。

ReentrantLock
  - 基于 AQS （AbstractQueuedSynchronizer）实现，主要有 state (资源) + FIFO (线程等待队列) 组成。
  - 公平锁与非公平锁：区别在于在获取锁时，公平锁会判断当前队列是否有正在等待的线程，如果有则进行排队。
  - 使用 lock() 和 unLock() 方法来加锁解锁。
- ReentrantReadWriteLock
  - 同样基于 AQS 实现，内部采用内部类的形式实现了读锁（共享锁）和写锁 （排它锁）。
```

### 5.乐观锁怎么去实现,业务场景里面是怎么实现的?

```
乐观锁就是每次去拿数据的时候,都认为别人不会修改,不会加锁,但在更新的时候会去判断一下,此期间别人有没有更新数据,版本号机制和CAS算法就用到乐观锁

实现方式
1.版本号机制，数据库
	这个机制一般是说在数据表中加上一个数据库版本号version字段，它会表述数据被修改的次数，当数据被修改时，它的version 值会加1。如果提交时版本号冲突则驳回当前过期的版本号信息。
2.CAS算法
	即compare and swap（比较和互换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。CAS算法涉及到3个操作数。
		1、需要读写的内存值V
		2、进行比较的值A
		3、拟写入的新值B
	当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

CAS和synchronized使用场景
1、对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
2、对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
```

### 6.MQ消费的幂等性?

```
对于每条消息，MQ内部生成一个全局唯一、与业务无关的消息ID：inner-msg-id。当MQ-server接收到消息时，先根据inner-msg-id判断消息是否重复发送，再决定是否将消息落地到DB中。这样，有了这个inner-msg-id作为去重的依据就能保证一条消息只能一次落地到DB。

1、对于非幂等性业务且要求实现幂等性业务：生成一个唯一ID标记每一条消息，将消息处理成功和去重日志通过事物的形式写入去重表。
2、对于非幂等性业务可不实现幂等性的业务：权衡去重所花的代价决定是否需要实现幂等性，如：购物会员卡成功，向用户发送通知短信，发送一次或者多次影响不大。不做幂等性可以省掉写去重日志的操作。

分布式幂等性
GTIS提供了一套可靠的解决方法：依赖于存储引擎，通过对不同操作所对应的唯一的内容特性生成一个唯一的全局ID来防止操作重复。
```

### 7.说一说对Redis的理解,在哪些场景下用到过

```
Redis非关系型数据库，以键值对形式存储，可以用作于数据库，缓存和消息队列

redis的特点: 速度快,支持持久化,可以处理高并发于分布式场景,可以搭建集群,主从复制

应用场景: 缓存(缓解数据库压力),统计在线人数(hash),点赞记数(set),队列(list)

类型：常用的String,list,hash,set,zset
其他还有bitmap,hyperLogLog等
```

### 8.Spring的核心要点原理?

```
Spring容器核心是IOC和AOP

IoC(Inversion of Control)控制反转。它是spring的核心之一。所谓IoC，意思就是由spring来负责控制对象的生命周期和对象间的关系。它分为构造方法注入，set方法注入，接口注入，我们最常用的就是set方法注入。

	举个简单例子：我们在用spring时用xml配置的方式的话，都会把bean配置在spring中，也有bean的property属性。spring容器在初始化时就通过反射将容器中的bean实例化，假如bean配置中有property属性，就会反射property属性注入到bean中，这就是控制反转。

AOP面向切面编程：考虑如何把散落在应用中多处相同的功能剥离出来，使得这些剥离出来的逻辑与业务逻辑相分离的问题。
```

### 9.自己独立完成的模块

```
商家模块
	购物车模块
	用户登录注册
```

### 10.Dubbo的了解,自己说?

```
Dubbo是基于Java的高性能轻量级的RPC分布式服务框架，主要提供了三个关键的功能，1.基于接口的远程调用；2.容错和负载均衡；3.自动服务注册和发现；

Dubbo的角色
1.容器 2.注册中心 3.服务提供者 4.服务消费者 5.监控中心

服务注册流程
1.容器启动，加载运行服务提供者
2.服务提供者启动时，向注册中心注册自己提供的服务
3.服务消费者启动时，向注册中心订阅自己需要的服务
4.注册中心返回服务提供者地址列表给消费者，保存到本地缓存，以后直接从缓存中获取。如果有变动，注册中心将基于长连接推送变更数据给消费者。
5.服务消费者从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败再选另一台调用。
6.服务提供者和消费者，在内存中累计调用次数和时间都会定时每分钟发送一次统计数到监控中心。

Dubbo框架设计（10层）
1.service服务层：接口层，给服务提供者和消费者来实现的
2.config配置层：配置层，主要是对 dubbo 进行各种配置的
3.proxy服务代理层：服务接口透明代理，生成服务的客户端 Stub和服务器端
4.registry服务注册层：负责服务的注册与发现
5.cluster集群层：封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务
6.monitor监控层：对 rpc 接口的调用次数和调用时间进行监
7.protocol远程调用层：封装 rpc 调用
8.exchange消息交换层：封装请求响应模式，同步转异步
9.transport网络传输层：抽象 mina和netty为统一接口
10.serialize数据序列化层：网络传输需要
```

## 自定义

### 1.Java类加载机制

```
java创建对象过程-> 加载(字节码文件)，验证(字节码文件正确性)，准备(为静态变量分配内存)，解析(将符号引用<全限定类名>解析为直接引用<类在实际内存中的地址>)，初始化(静态变量赋初始值)
```

### 2.双亲委派模式

```
当一个类需要加载时，判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的loadClass()处理，因此所有的请求最终都应该传送到顶层的启动类加载器BootstrapClassLoader中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器BootstrapClassLoader作为父类加载器
```

### 3.sleep与wait的区别

```
wait：可以指定时间也可以不指定时间。不指定时间. 只能由对应的notify或者notifyAll来唤醒。
sleep：必须指定时间. 时间到自动从冻结状态转成运行状态(临时阻塞状态)。
wait：线程会释放执行权. 而且线程会释放锁。
Sleep：线程会释放执行权. 但不是不释放锁。
```

### 4.springmvc工作流程

```
1.用户请求到 DispatcherServlet
2.收到请求后，DispatcherServlet调用HandlerMapping，获取对应的Handler
3.如果有拦截器一并返回
4.拿到Handler后，找到HandlerAdapter通过它来访问Handler，并执行处理器
5.执行Handler的逻辑
6.Handler会返回一个ModelAndView对象给DispatcherServlet
7.请求ViewResolver解析视图，根据逻辑视图名解析成真正的View
8.返回View给DispatcherServlet
9.DispatcherServlet对View进行渲染视图
10.DispatcherServlet响应用户
```

### 5.bean的生命周期

```
1. 实例化 Instantiation
2. 属性赋值 Populate
3. 初始化 Initialization
4. 销毁 Destruction

实例化三种方式
1.使用默认构造方法创建
2.使用工厂普通方法创建对象(使用某个类中的方法创建对象,并存入spring容器)
3.使用工厂静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器)
```

### 6.强引用，软引用，弱引用，虚引用

| 引用类型 | 被垃圾回收时间 | 用途           | 生存时间          |
| -------- | -------------- | -------------- | ----------------- |
| 强引用   | 从来不会       | 对象的一般状态 | JVM停止运行时终止 |
| 软引用   | 当内存不足     | 对象缓存       | 内存不足终止      |
| 弱引用   | 在垃圾回收时   | 对象缓存       | gc运行后终止      |
| 虚引用   | unknown        | unknown        | unknown           |

### 7.zookeeper的理解

```
ZooKeeper 是一个集中式服务，用于维护配置信息，命名，提供分布式同步和提供组服务，
在这个项目 zookeeper 主要也是作为注册中心来使用。其实 dubbo 的注册中心也可以使用
Redis 来实现的。

至于怎么实现。主要用到了 Redis 两点功能
1.key-value 的存储
2.发布和订阅的消息机制
具体的配置可以跟您简单说一下
连接 redis 服务器；
服务消费者启动后从 key 值中获取服务提供者地址；
服务消费者订阅服务提供者启动的消息；
服务消费者设置地址；
当有新的服务提供者上线时，重新获取服务提供者地址列表。
```

### 8.了解nginx吗？

```
Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 Nginx 主要提供反向代理、负载均衡、动静分离(静态资源服务)等服务

我们项目上线之后用的是一个负载均衡，现在用的比较多了，就我了解的像新浪，搜狐，快手都有用到，其实就是一个负载均衡服务器，反向代理，我们在访问项目的时候是不需要直接访问服务器的，而是访问 ngnix 服务器，由 ngnix 来决定访问哪一个服务器，在ngnix.config 配置文件里面配置代理服务器，想代理几台就代理几台，就那台服务器配置高点的话，可以配置一个 weight,就是配置一个权重，把权重配置的稍微大点，如果是服务器的配置低的话呢，我们也可以配置 weight 低一点，像项目后期的测试这块，我也都有跟进过。我们用的是 windows 版本的 ngnix,包括在 linux上的也都有实现过，最终项目上线的时候，是上线到 linux 上的，ngnix 用的是两台服务器，其实还有一台是三台，一主一备，还有一个高可用的一个服务，让ngnix 的主节点和备用服务器呢，来传输一个心跳协议，来检测状态。如果主节点挂掉的话，就是从的，那个备用服务器会立马启动起来工作，然后运维人员对主节点进行相应的维修，再次重新启动，再转回主节点。

nginx四个主要组成部分？
	Nginx 二进制可执行文件：由各模块源码编译出一个文件
	Nginx.conf 配置文件：控制 Nginx 行为
	acess.log 访问日志： 记录每一条 HTTP 请求信息
	error.log 错误日志:
	
nginx特点：
1. 高并发，高性能
2. 可扩展性好（模块化设计，第三方插件生态圈丰富）
3. 高可靠性（可以在服务器行持续不间断的运行数年）
4. 热部署（这个功能对于 Nginx 来说特别重要，热部署指可以在不停止 Nginx 服务的情况下升级 Nginx）
5. BSD 许可证（意味着我们可以将源代码下载下来进行修改然后使用自己的版本）
```

### 9.动静分离

```
动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来， 动静资源做好了拆分以 后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路
```

### 10.工作中遇到的问题：

```
1、内存溢出，可以调节 tomcat 内存解决。还要找出代码中内存溢出的漏洞，一般是流没 有关闭或者死循环； 
2、数据库连接超出最大连接量：修改 mysql 配置文件的最大连接数； 
3、代码编译失败、缓存：清理 Eclipse 编译缓存、清理 tomcat 缓存、清理浏览器缓存。 
4、tomcat 启动端口号被占用：打开任务管理器，杀进程； 
5、tomcat 启动超时：修改启动时间
```

### 11.项目并发量

```
- tomcat一台500max(300-400)
- 200并发量考虑使用集群
- 一万用户量
  - 日活动量(*20%) 2000左右
  - 并发量(*20) 400左右
  - tomcat 两台
  - 租金价格一个月一万左右

- 100人访问量单体架构
  - mybatis
  - Spring
  - Spring MVC

- 1000人访问量
  - 集群:
    - nginx(双机热备)
    - keepLived(心跳检测)
```

### 12.谈谈你对AQS的理解。AQS如何实现可重 入锁？

```
1、AQS是一个JAVA线程同步的框架。是JDK中很多锁工具的核心实现框架。 
2、 在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的。 在不同的场景下，有不用的意义。 
3、在可重入锁这个场景下，state就用来表示加锁的次数。0标识无锁，每加一次 锁，state就加1。释放锁state就减1
```

### 13.布隆过滤器

```
直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

算法：
1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

优点：不需要存储key，节省空间

缺点：
1. 算法判断key在集合中时，有一定的概率key其实不在集合中
2. 无法删除
```

### 14.linux指令

```
查看日志倒序
tail -f /var/log/messages

docker
启动/停止docker systemctl start/stop docker
下载镜像docker pull
删除镜像docker rmi 镜像id/镜像名：版本号
保存镜像docker save -o 路径 镜像名：版本号
备份文件docker load -i 镜像文件路径
进入容器docker exec -it 容器名 /bin/bash
删除容器docker rm 容器名称或容器id
创建并运行docker docker run -dti --name=命名 镜像名:版本号 /bin/bash
	-d 表示守护式容器
	-i 运行容器
	-t 交互 (后面跟交互shell脚本)
	版本号映射 -p 宿主机端口:容器端口
```

### 15.mybatis,JDBC

```
Mybatis 原理
	MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。
	MyBatis使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Ordinary Java Objects，普通的 Java对象）映射成数据库中的记录。
	每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。用xml文件构建SqlSessionFactory实例是非常简单的事情。

JDBC步骤
1. 加载驱动
2. 获取连接
3. 定义要执行的语句
4. 创建要执行sql语句的预编译处理对象并设置参数
5. 执行sql语句
6. 处理结果集
7. 关闭连接,释放资源
```

### 16.红黑树

```
特点:比avl简单但是更抽象
	avl树左右高度差不超过1,是严格的平衡树,两个结点就是1
	红黑树达到的是近似平衡树保证最长路径不超过最短路径的二倍
	红黑树是一种二叉搜索树但是在每个结点上增加一个存储位表示颜色,颜色可以为red/balck通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的--->切记红黑树是近平衡的
	
红黑树的性质
1.每个结点不是黑色就是红色
2.根是黑色
3.如果一个节点是红色的，则它的两个孩子结点是黑色的
4.对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点 —保证了最长路径不超过最短路径的二倍

对结点进行标记,根节点是黑色,一个结点红色孩子一定是黑也就是只有–>红黑 黑黑,没有红红,所以—>每条路径上有相同路径的黑结点四点约束达到了最长路径不超过最短路径的二倍,
最短路径一定是全黑最长路径一定是黑+红
```

### 17.b/b+树

```
B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。
	根节点至少有两个子节点
	每个节点有M-1个key，并且以升序排列
	位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
	其它节点至少有M/2个子节点
	
B+树是对B树的一种变形树，它与B树的差异在于：
	有k个子结点的结点必然有k个关键码；
	非叶结点仅具有索引作用，跟记录有关的信	息均存放在叶结点中。
	树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。
```

### 18.springcloud

版本对应(Spring Cloud|Spring Boot)

| Release Train                                                | Boot Version                     |
| :----------------------------------------------------------- | :------------------------------- |
| [2020.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes) aka Ilford | 2.4.x                            |
| [Hoxton](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes) | 2.2.x, 2.3.x (Starting with SR5) |
| [Greenwich](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes) | 2.1.x                            |
| [Finchley](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes) | 2.0.x                            |
| [Edgware](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes) | 1.5.x                            |
| [Dalston](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes) | 1.5.x                            |

spring cloud常用组件

```
注册中心(eureka),负载均衡器(ribbon),声明式RESTFUL客户端(feign),熔断器(hystrix),服务网关(zuul),配置中心(config),数据监控(acutor)

与dubbo区别：
SpringCloud与dubbo的区别: 注册中心(eureka|zookeeper), 服务调用方式(RESTFUL|RPC), 服务监控(SpringBoot Admin|Dubbo-monitor), springcloud其他有的角色dubbo都没有
```

### 19.@Autowired与@Resource的区别?

```
@Autowired 默认的是按照类型进行注入, 如果没有类型会按照名称(红色字体)进行注入. 如果想直接按照名称注入需要加入@Qualifier("gatheringDao")
@Autowired
@Qualifier("gatheringDao")
private GatheringDao gatheringDao;
@Resource 默认的会按照名称注入,名称找不着会按照类型来找,如果这里写了名称,就直接
按照名称找了不会按类型找@Resource(name = "aaa")
@Resource
private GatheringDao gatheringDao;
```

